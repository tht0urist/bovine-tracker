/*
 * Copyright 2020 ObjectBox Ltd. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// automatically generated by the FlatBuffers compiler, do not modify
// swiftlint:disable all



///  Not really an enum, but binary flags to use across languages
public enum DebugFlags: UInt32 {
    public typealias T = UInt32
    public static var byteSize: Int { return MemoryLayout<UInt32>.size }
    public var value: UInt32 { return self.rawValue }
    case logTransactionsRead = 1
    case logTransactionsWrite = 2
    case logQueries = 4
    case logQueryParameters = 8
    case logAsyncQueue = 16
    case logCacheHits = 32
    case logCacheAll = 64
    

    public static var max: DebugFlags { return .logCacheAll }
    public static var min: DebugFlags { return .logTransactionsRead }
}

///  Defines a padding mode for putting data bytes.
///  Depending on how that data is created, this mode may optimize data handling by avoiding copying memory.
///  Internal background: data buffers used by put operations are required to have a size divisible by 4 for an
///                       efficient data layout.
public enum PutPaddingMode: UInt16 {
    public typealias T = UInt16
    public static var byteSize: Int { return MemoryLayout<UInt16>.size }
    public var value: UInt16 { return self.rawValue }
    ///  Not a real type, just best practice (e.g. forward compatibility)
    case unknown = 0
    ///  Adds a padding when needed (requiring to copy memory): this is the safe option and also the default.
    ///  The extra memory copy may impact performance, however this is usually not noticeable.
    case paddingautomatic = 1
    ///  Indicates that data buffers are safe to be extended for padding (adding up to 3 bytes to size is OK).
    ///  Typically, it depends on the used FlatBuffers builder; e.g. the official C++ seems to ensure it, but
    ///  flatcc (3rd party implementation for plain C) does not.
    case paddingallowedbybuffer = 2
    ///  The caller ensures that all data bytes are already padded.
    ///  ObjectBox will verify this and throws an exception if this is violated.
    case paddingbycaller = 3
    

    public static var max: PutPaddingMode { return .paddingbycaller }
    public static var min: PutPaddingMode { return .unknown }
}

///  Defines if and how the database is checked for structural consistency when opening it.
public enum ValidateOnOpenMode: UInt16 {
    public typealias T = UInt16
    public static var byteSize: Int { return MemoryLayout<UInt16>.size }
    public var value: UInt16 { return self.rawValue }
    ///  Not a real type, just best practice (e.g. forward compatibility)
    case unknown = 0
    ///  No additional checks are performed. This is fine if your file system is reliable (which it typically should be).
    case none_ = 1
    ///  Performs a limited number of checks on the most important database structures (e.g. "branch pages").
    case regular = 2
    ///  Performs a limited number of checks on database structures including "data leaves".
    case withleaves = 3
    ///  Performs a unlimited number of checks on the most important database structures (e.g. "branch pages").
    case allbranches = 4
    ///  Performs a unlimited number of checks on database structures including "data leaves".
    case full = 5
    

    public static var max: ValidateOnOpenMode { return .full }
    public static var min: ValidateOnOpenMode { return .unknown }
}
